/**
 * Handles validation, parsing and submission of custom forms.
 * Forms are submitted as a JSON object in the following format:
 * uuid: service UUID
 * type: the id of the page (e.g. "layer") -> Used by the backend to determine which deserializer to use
 * data: the data of the form (e.g. the data of a layer) -> Deserialized to the corresponding object by the Backend
 */
class FormSubmitter {

    /**
     * Submits the data of a form to the given PHP handler using a POST HTTP request.
     * Check the docs of #autoParseInputElements to correctly set up your forms.
     * A specialCaseFunction can be passed to add content to the submission that can't be autogenerated.
     * @param serviceUUID uuid of the service
     * @param type id of the page which is used by the backend
     * @param formID id of the form
     * @param handlerLocation name and location of the PHP file, relative to the calling file
     * @param specialCaseFunction a function to execute
     * @return boolean if the form is valid for submission
     */
    attemptSubmitFormData(serviceUUID, type, formID, handlerLocation, specialCaseFunction) {
        if (this.#formIsValid()) {
            const formSelector = '#' + formID;
            const inputElements = $(formSelector + ' input').toArray();
            const optionElements = $(formSelector + ' select').toArray();
            this.#sendPOST(handlerLocation, this.#buildPayload(serviceUUID, type, inputElements, optionElements, specialCaseFunction));
            return true;
        } else {
            return false;
        }
    }

    /**
     * Checks the validity of all inputs with the 'needs-validation' class.
     * Styling will be applied based on the validity of every single input.
     * @returns {boolean} if all inputs contain valid data
     */
    #formIsValid() {
        const forms = $('.needs-validation')
        let isValid = true;
        Array.from(forms).forEach(form => {
            if (!form.checkValidity()) {
                isValid = false;
            }
            form.classList.add('was-validated')
        });
        return isValid;
    }

    #sendPOST(handlerLocation, payload) {
        fetch('http://localhost/api/formHandler/' + handlerLocation, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
        });
    }

    /**
     * Builds the payload based on an autogenerated json and 'specialCase' functions.
     * The 'specialCase' function is executed with the autogenerated json as its only argument.
     * It is expected to return a modified version of the json for further processing.
     * @param uuid uuid of the service
     * @param type id of the page which is used by the backend
     * @param inputElements a list of input elements
     * @param optionElements a list of all option elements
     * @param specialCaseFunction a function to execute
     * @returns An object representing all user input
     */
    #buildPayload(uuid, type, inputElements, optionElements, specialCaseFunction) {
        const inputJson = this.#autoParseInputElements(inputElements);
        const optionJson = this.#autoParseOptionElements(optionElements);

        let payload = {
            uuid: uuid,
            type: type
        };

        let json = {...inputJson, ...optionJson}
        payload.data = specialCaseFunction !== undefined ? specialCaseFunction(json) : json;
        return payload;
    }

    /**
     * Builds an object from all the given input fields.
     * Empty fields ("") are explicitly set to null (except for nested objects).
     * <br>
     * If an input field's ID contains a dash (-), a nested object will be created.
     * This nested object will be named like the part before the dash, the part after
     * the dash will be the key to the value in that nested object.
     * <br>
     * This behaviour makes it easier to parse properties that belong together on the server side.
     * @param inputElements an object that contains input elements
     * @returns An object representing all input fields and their values
     */
    #autoParseInputElements(inputElements) {
        let payload = {};
        inputElements.forEach(input => {
            let id = input.id;
            let value = input.value;

            let parts = id.split('-')

            if (parts.length === 1) {
                if (value === "") {
                    payload[id] = null;
                } else {
                    payload[id] = value;
                }
            } else {
                if (payload[parts[0]] == null) {
                    payload[parts[0]] = {};
                }
                payload[parts[0]][parts[1]] = value;
            }
        });
        return payload;
    }

    #autoParseOptionElements(optionElements) {
        let payload = {};
        optionElements.forEach(option => {
            const selectedValue = option.options[option.selectedIndex].value;
            payload[option.id] = selectedValue === "" ? null : selectedValue;
        });

        return payload;
    }
}
